\chapter{Конструкторская часть}

По построенной ER диаграмме, можно выделить следующие сущности БД:

\section{Требования к программному обеспечению}

Разрабатываемое программное обеспечение должно предоставлять
следующие функциональные возможности:

\begin{itemize}
  \item генерация случайного графа заданной плотности;
  \item сохранение графа в базу данных;
  \item выполнение алгоритма Louvain;
  \item визуализация сообществ.
\end{itemize}


\section{Проектирование базы данных}

В таблице~\ref{tbl:usr} представлено описание объекта пользователя.

\begin{table}[H]
	\begin{center}
		\begin{threeparttable}
			\caption{Сущность <<Пользователь>>}
			\label{tbl:usr}
			\begin{tabularx}{\textwidth}{|c|c|X|}
			\hline
			\textbf{Поле} & \textbf{Тип} & \textbf{Описание} \\
			\hline
			id & Целочисленный тип & Уникальный идентификатор пользователя социальной сети \\
			\hline
			name & Текстовый тип & Имя пользователя \\
			\hline
			\end{tabularx}
		\end{threeparttable}
	\end{center}
\end{table}

В таблице~\ref{tbl:com} представлено описание объекта сообщества.

\begin{table}[H]
	\begin{center}
		\begin{threeparttable}
			\caption{Сущность <<Сообщество>>}
			\label{tbl:com}
			\begin{tabular}{|c|c|c|}
			\hline
			\textbf{Поле} & \textbf{Тип} & \textbf{Описание} \\
			\hline
			id & Целочисленный тип & Уникальный идентификатор сообщества \\
			\hline
			level & Целочисленный тип & Уровень сообщества \\
			\hline
			members & Целочисленный массив & Id членов сообщества \\
			\hline
			\end{tabular}
		\end{threeparttable}
	\end{center}
\end{table}

\subsection{Алгоритм разметки людей по сообществам}

После получения супер графа, необходимо каждому человеку сопоставить id тех сообществ в которых он состоит (порядок должен отображать иерархию). Для осуществления этой цели был выбран алгоритм <<dfs>> (\textit{Depth-first search}). Заключается он в следующем:


\begin{enumerate}[label=\arabic*.]
    \item \textbf{Инициализация:}
    \begin{enumerate}[label=\arabic*.]
        \item Создаётся стек, в который помещаются кортежи вида $(id, level, labels)$, где:
        \begin{itemize}
            \item $id$ --- идентификатор вершины;
            \item $level$ --- оставшееся количество уровней обхода;
            \item $labels$ --- список тегов (путь до текущей вершины).
        \end{itemize}
        \item В стек помещаются все вершины из начального списка с уровнем $level$ и пустым списком тегов.
    \end{enumerate}

    \item \textbf{Основной цикл:}
    \begin{enumerate}[label=\arabic*.]
        \item Пока стек не пуст, извлекается вершина $(id, level, labels)$.
        \item Если $level > 0$, то:
        \begin{itemize}
            \item К списку тегов добавляется текущий $id$;
            \item С помощью метода \texttt{GetChild(id, level)} запрашиваются дочерние вершины;
            \item Каждая дочерняя вершина помещается в стек с уровнем $level - 1$ и копией расширенного списка $labels$.
        \end{itemize}
        \item Если $level = 0$, то:
        \begin{itemize}
            \item Вызывается метод \texttt{Tag(id, labels)} для сохранения тегов вершины.
        \end{itemize}
    \end{enumerate}

    \item \textbf{Особенности:}
    \begin{itemize}
        \item Алгоритм использует стек вместо рекурсии, что позволяет избежать переполнения стека вызовов;
        \item Метки накапливаются при прохождении по иерархии и наследуются потомками;
        \item Поддерживается асинхронность при обращении к внешним источникам данных (\texttt{GetChild}, \texttt{Tag});
        \item Глубина обхода ограничена параметром $level$.
    \end{itemize}
\end{enumerate}


\section*{Вывод}

В рамках конструкторской части были выделены основные сущности и отношения предметной области, отражающие структуру социальной сети и её сообществ. На основании этого была спроектирована база данных, ориентированная на хранение и обработку графовых данных.

Также был разработан алгоритм разметки пользователей по сообществам, учитывающий иерархическую структуру. Использование обхода в глубину (DFS) с явным стеком обеспечивает корректную работу с глубокими уровнями вложенности и позволяет эффективно сопоставлять каждому пользователю все уровни его принадлежности. Предложенная структура и методы обеспечивают надёжную основу для дальнейшей обработки и анализа социальной графовой модели.
